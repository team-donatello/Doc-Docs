{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _reactDnd = require('react-dnd');\n\nvar _Util = require('./Util');\n\nvar _DnDTypes = require('./DnDTypes');\n\nvar _index = require('./index');\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar DnDContext = function DnDContext(sources, DecoratedComponent) {\n  var _this = this;\n\n  _classCallCheck(this, DnDContext);\n\n  this.getDropSpec = function () {\n    return {\n      drop: function drop(props, monitor, component) {\n        var schedulerData = props.schedulerData,\n            resourceEvents = props.resourceEvents;\n        var cellUnit = schedulerData.cellUnit,\n            localeMoment = schedulerData.localeMoment;\n        var type = monitor.getItemType();\n        var pos = (0, _Util.getPos)(component.eventContainer);\n        var cellWidth = schedulerData.getContentCellWidth();\n        var initialStartTime = null,\n            initialEndTime = null;\n\n        if (type === _DnDTypes.DnDTypes.EVENT) {\n          var initialPoint = monitor.getInitialClientOffset();\n          var initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n          initialStartTime = resourceEvents.headerItems[initialLeftIndex].start;\n          initialEndTime = resourceEvents.headerItems[initialLeftIndex].end;\n          if (cellUnit !== _index.CellUnits.Hour) initialEndTime = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n        }\n\n        var point = monitor.getClientOffset();\n        var leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n        var startTime = resourceEvents.headerItems[leftIndex].start;\n        var endTime = resourceEvents.headerItems[leftIndex].end;\n        if (cellUnit !== _index.CellUnits.Hour) endTime = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n        return {\n          slotId: resourceEvents.slotId,\n          slotName: resourceEvents.slotName,\n          start: startTime,\n          end: endTime,\n          initialStart: initialStartTime,\n          initialEnd: initialEndTime\n        };\n      },\n      canDrop: function canDrop(props, monitor) {\n        var schedulerData = props.schedulerData;\n        var item = monitor.getItem();\n        if (schedulerData._isResizing()) return false;\n        var config = schedulerData.config;\n        return config.movable && (item.movable == undefined || item.movable !== false);\n      }\n    };\n  };\n\n  this.getDropCollect = function (connect, monitor) {\n    return {\n      connectDropTarget: connect.dropTarget(),\n      isOver: monitor.isOver()\n    };\n  };\n\n  this.getDropTarget = function () {\n    return (0, _reactDnd.DropTarget)([].concat(_toConsumableArray(_this.sourceMap.keys())), _this.getDropSpec(), _this.getDropCollect)(_this.DecoratedComponent);\n  };\n\n  this.getDndSource = function () {\n    var dndType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _DnDTypes.DnDTypes.EVENT;\n    return _this.sourceMap.get(dndType);\n  };\n\n  this.sourceMap = new Map();\n  sources.forEach(function (item) {\n    _this.sourceMap.set(item.dndType, item);\n  });\n  this.DecoratedComponent = DecoratedComponent;\n};\n\nexports.default = DnDContext;","map":null,"metadata":{},"sourceType":"script"}